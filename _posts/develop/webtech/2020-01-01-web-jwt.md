---
title: '[Web] JWT'
date: 2020-01-01 22:20:00 -0400
categories: devlog
tags: web devlog jwt auth
---

## 표준 프로토콜 지원

### SAML 2.0 (Security Assertion Markup Language)

XML 기반의 인증 프로토콜복잡하고 무거운 구조네이티브 어플리케이션, 모바일 환경에 적용하기에는 부적합

### OAuth 2.0 (Open Authorization)

API를 사용하여 자원에 접근하기 위한 오픈 표준다양한 플랫폼 환경에서 권한 부여를 위한 프로토콜클라이언트에게 제한된 접근을 하도록 권한을 부여하는 일종의 프레임워크

### OpenID Connect 1.0

OAuth 2.0 권한 부여 프로토콜을 기반으로 이를 확장한 프로토콜 JSON/REST 기반의 상호 운용 가능한 인증 프로토콜모바일 환경까지 고려한 설계로 다양한 플랫폼에 적용 가능

## JWT, OAuth와 관계

토큰 기반의 인증 시스템을 공부 할 때 두가지의 개념이 헷갈릴 수 있다. **JWT** 는 Token 유형,

**OAuth** 는 Token을 발급하고 인증하는 방법을 설명하는 일종의 프레임워크

```
OAuth 2.0은 프로토콜을 정의합니다. 즉, 토큰 전송 방법을 지정하고 JWT는 토큰 형식을 정의합니다.
OAuth 2.0과 "JWT 인증"은 클라이언트가 리소스 서버에 토큰을 제공하는 2 단계 (단계)에서 비슷한 모양을 갖습니다. 토큰은 헤더로 전달됩니다.

그러나 "JWT 인증"은 표준이 아니며 how 를 지정하지 않습니다. 클라이언트는 첫 번째 (1 단계)에서 토큰을 얻습니다. 그것이 OAuth의 복잡성을 인식 한 곳입니다. 또한 클라이언트가 Authorization이라는 것을 통해 액세스 토큰을 obtain 할 수있는 다양한 방법을 정의합니다. 섬기는 사람.

따라서 실제 차이점은 JWT는 단지 토큰 형식이고 OAuth 2.0은 프로토콜입니다 ( may JWT를 토큰 형식으로 사용함).
```

```
첫째, 우리는 JWT와 OAuth를 구별해야합니다. 기본적으로 JWT는 토큰 형식입니다. OAuth는 JWT를 토큰으로 사용할 수있는 권한 부여 프로토콜입니다. OAuth는 서버 측 및 클라이언트 측 저장소를 사용합니다. 실제 로그 아웃을 원할 경우 OAuth2를 사용해야합니다. JWT 토큰을 사용한 인증은 실제로 로그 아웃 할 수 없습니다. 토큰을 추적하는 인증 서버가 없기 때문입니다. 제 3 자 클라이언트에 API를 제공하려면 OAuth2도 사용해야합니다. OAuth2는 매우 유연합니다. JWT 구현은 매우 쉽고 구현에 오래 걸리지 않습니다. 애플리케이션에 이러한 유연성이 필요한 경우 OAuth2를 사용해야합니다. 그러나이 유스 케이스 시나리오가 필요하지 않은 경우 OAuth2를 구현하는 것은 시간 낭비입니다.
```

```
JWT (JSON Web Tokens)- 이것은 단지 토큰 형식입니다. JWT 토큰은 발급자, 제목 (클레임), 만료 시간 등에 대한 정보를 포함하는 JSON 인코딩 된 데이터 구조입니다. 변조 및 신뢰성을 위해 서명되며 대칭 또는 비대칭 접근 방식을 사용하여 토큰 정보를 보호하기 위해 암호화 될 수 있습니다. JWT는 SAML 1.1/2.0보다 간단하며 모든 장치에서 지원되며 SWT (Simple Web Token)보다 강력합니다.

OAuth2 - OAuth2는 사용자가 브라우저 기반 웹 앱, 기본 모바일 앱 또는 데스크톱 앱과 같은 클라이언트 소프트웨어를 사용하여 데이터에 액세스하려고하는 문제를 해결합니다. OAuth2는 인증 용이며 클라이언트 소프트웨어는 액세스 토큰을 사용하여 최종 사용자를 대신하여 리소스에 액세스 할 수있는 권한을 부여받을 수 있습니다.

OpenID Connect _ - OpenID Connect는 OAuth2 위에 구축되고 인증을 추가합니다. OpenID Connect는 UserInfo Endpoint, ID Token, OpenID Connect 제공자의 동적 등록 및 세션 관리와 같은 OAuth2에 일부 제약 조건을 추가합니다. JWT는 토큰의 필수 형식입니다.

CSRF 보호 - 브라우저의 쿠키에 토큰을 저장하지 않으면 CSRF 보호 기능을 구현할 필요가 없습니다.
```

```
액세스 토큰을 갖는 요점은 무효화를 확인하지 않고 사용할 수 있다는 것입니다. 일부 데이터베이스가 유효하지 않은지 묻지 않아도 10000 개의 프런트 엔드 서버 사용자가 토큰으로 액세스 할 수 있습니다. 그러나 얼마 후 토큰이 만료됩니다. 사용자는 새로운 액세스 토큰이 필요하고 새로 고침 토큰을 보내고이 새로 고침 토큰은 일부 데이터베이스에서 확인됩니다. 만료 된 액세스 토큰을 확인하거나 상태를 확인할 필요는 없지만 남용을 토큰 수명으로 제한합니다.

데이터베이스에서 만료를 확인하지 않고 토큰을 수락 할 필요가없는 경우 서로 다른 두 개의 토큰이 필요하지 않습니다. 각 액세스마다 새로 고침 토큰을 사용할 수 있습니다.

워크 플로의 예는 다음과 같습니다.

사용자가 로그인하여 액세스하고 토큰을 새로 고칩니다. 액세스 토큰 수명 15 분, 새로 고침 토큰 5 일.

사용자는 액세스 토큰을 사용하여 서비스에 액세스합니다. 서비스는 서명과 수명 만 확인합니다. 데이터베이스 연결이 없습니다.

사용자가 로그 아웃하면 새로 고침 토큰이 데이터베이스 에서 만료 된 것으로 표시 됩니다.
사용자는 액세스 토큰을 사용하여 서비스에 액세스하지만 여전히 작동합니다
15 분 패스 액세스 토큰이 만료되면 사용자는 여전히 유효 기간 내에 새로 고침 토큰을 사용하여 새 액세스 토큰을 요청합니다. 서비스는 데이터베이스를 확인하고 토큰이 만료 된 것을 찾습니다. 사용자는 새로운 액세스 토큰을 얻을 수 없습니다.
전체 시스템은 세션을 무효화하는 데 걸리는 시간과 필요한 공유 / 동기화 된 데이터 소스에 대한 연결 양 사이의 균형입니다.

각 새로 고침마다 새로 고침 토큰을 교체 할 수 있지만 수명이 끝날 때까지 만료 된 모든 새로 고침 토큰 을 저장 해야합니다 .

보안 관점에서 새 토큰을 만드는 것이 합리적이지만 데이터베이스의 보안과 데이터 양 간의 균형을 유지합니다.

최악의 경우 (새로 고침 토큰의 수명이 없으면 절대 그렇게 하지 마십시오) 이제 각 사용자에 대해 하나의 토큰 대신 각 사용자에 대해 데이터베이스에 몇 분마다 하나의 토큰을 저장해야하며 다시 제거 할 수 없습니다.
```

# 참고 문서

https://bcho.tistory.com/999 https://velopert.com/2389 https://swalloow.github.io/implement-jwt http://www.opennaru.com/opennaru-blog/jwt-json-web-token/

https://velog.io/@city7310/%EB%B0%B1%EC%97%94%EB%93%9C%EA%B0%80-%EC%9D%B4%EC%A0%95%EB%8F%84%EB%8A%94-%ED%95%B4%EC%A4%98%EC%95%BC-%ED%95%A8-5.-%EC%82%AC%EC%9A%A9%EC%9E%90-%EC%9D%B8%EC%A6%9D-%EB%B0%A9%EC%8B%9D-%EA%B2%B0%EC%A0%95

https://auth0.com/blog/refresh-tokens-what-are-they-and-when-to-use-them/ https://velog.io/@mycampground/Permissions-Token-Authentication-%EC%86%8C%EA%B0%9C

https://solidgeargroup.com/refresh-token-with-jwt-authentication-node-js/
